import { useEffect, useRef, useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import "mapbox-gl/dist/mapbox-gl.css";
import "leaflet/dist/leaflet.css";
import "@/styles/leaflet-fixes.css";
import Supercluster from "supercluster";

type Point = {
  id?: number;
  lat: number;
  lon: number;
  date?: string | null;
  photographer?: string | null;
  total?: number | null;
};

type Props = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  points: Point[];
  totalFiltered?: number;
  children?: React.ReactNode;
  onSelect?: (sightingId: number) => void;

  onSelect?: (sid: number) => void;
};

export default function MapDialog({
  open,
  onOpenChange,
  points,
  totalFiltered,
  children,
  onSelect,
}: Props) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const mapHolder = useRef<any>(null);
  const [engine, setEngine] = useState<"leaflet" | "mapbox" | "none">("none");
  
  useEffect(() => { if (!open) return; (window as any).__map_onSelect = (sid:number)=> onSelect?.(sid); 
  // [map-bridge:onSelect]
useEffect(() => {
    (window as any).__map_onSelect = (sid: number) => onSelect?.(sid);
    (window as any).handleSelectFromMap = (sid: number) => onSelect?.(sid); // back-compat
    return () => {
      try {
        delete (window as any).__map_onSelect;
        delete (window as any).handleSelectFromMap;
      } catch {}
    };
  }, [onSelect]);
return () => { try { delete (window as any).__map_onSelect } catch(_) {} }; }, [open, onSelect]);
const [ready, setReady] = useState(false);

  // bridge for popup links -> parent handler
  useEffect(() => {
    if (!open) return;
    (window as any).__map_onSelect = (sid: number) => onSelect?.(sid);
    return () => {
      try { delete (window as any).__map_onSelect; } catch {}
    };
  }, [open, onSelect]);

  useEffect(() => {
    if (!open) return;
    let cancel = false;
    (async () => {
      const token = (import.meta.env as any).VITE_MAPBOX_TOKEN as string | undefined;
      const mapboxSupported = !!token && (await webglSupported());
      if (!cancel) setEngine(mapboxSupported ? "mapbox" : "leaflet");
    })();
    return () => { cancel = true; };
  }, [open]);

  useEffect(() => {
    if (open) {
      setReady(false);
      Promise.resolve().then(() => requestAnimationFrame(() => setReady(true)));
    } else {
      setReady(false);
      if (mapHolder.current?.map) { try { mapHolder.current.map.remove(); } catch {} }
      mapHolder.current = null;
      if (containerRef.current) try { containerRef.current.innerHTML = ""; } catch {}
      setEngine("none");
    }
  }, [open]);

  useEffect(() => {
    if (!open || !ready || engine === "none") return;
    const el = containerRef.current;
    if (!el) return;
    try { el.innerHTML = ""; } catch {}

    if (engine === "mapbox") {
      (async () => {
        const mapboxgl = (await import("mapbox-gl")).default as any;
        mapboxgl.accessToken = (import.meta.env as any).VITE_MAPBOX_TOKEN;
        const map = new mapboxgl.Map({
          container: el,
          style: "mapbox://styles/mapbox/outdoors-v12",
          center: [0, 0],
          zoom: 2,
        });
        map.addControl(new mapboxgl.NavigationControl(), "top-right");
        mapHolder.current = { map, engine: "mapbox" };

        map.on("load", () => {
          const fc = {
            type: "FeatureCollection",
            features: (points || []).map((p) => ({
              type: "Feature",
              properties: { id: p.id ?? null },
              geometry: { type: "Point", coordinates: [p.lon, p.lat] },
            })),
          };
          map.addSource("sightings", {
            type: "geojson",
            data: fc,
            cluster: true,
            clusterMaxZoom: 16,
            clusterRadius: 40,
          });
          map.addLayer({
            id: "clusters",
            type: "circle",
            source: "sightings",
            filter: ["has", "point_count"],
            paint: {
              "circle-color": "#2563eb",
              "circle-radius": ["step", ["get", "point_count"], 16, 10, 20, 50, 26, 100, 32],
              "circle-stroke-color": "#fff",
              "circle-stroke-width": 1,
            },
          });
          map.addLayer({
            id: "cluster-count",
            type: "symbol",
            source: "sightings",
            filter: ["has", "point_count"],
            layout: {
              "text-field": "{point_count_abbreviated}",
              "text-size": 12,
              "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
            },
            paint: { "text-color": "#fff" },
          });
          map.addLayer({
            id: "unclustered-point",
            type: "circle",
            source: "sightings",
            filter: ["!", ["has", "point_count"]],
            paint: {
              "circle-color": "#2563eb",
              "circle-radius": 10,
              "circle-stroke-color": "#fff",
              "circle-stroke-width": 1,
            },
          });
          map.addLayer({
            id: "unclustered-count",
            type: "symbol",
            source: "sightings",
            filter: ["!", ["has", "point_count"]],
            layout: {
              "text-field": "1",
              "text-size": 11,
              "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
              "text-offset": [0, 0],
              "text-anchor": "center",
            },
            paint: { "text-color": "#fff" },
          });

          map.on("click", "unclustered-point", (e: any) => {
            const f = e.features?.[0];
            const id = f?.properties?.id;
            if (!id) return;
            const coord = f.geometry.coordinates;
            const linkId = `mb-sel-${id}-${Math.floor(Math.random() * 1e6)}`;
            const html = `<div style="font-size:12px;line-height:1.25">
                <div><b>Sighting</b> <a id="${linkId}" href="#">${id}</a></div>
              </div>`;
            new mapboxgl.Popup().setLngLat(coord).setHTML(html).addTo(map);
            setTimeout(() => {
              const a = document.getElementById(linkId);
              if (a) {
                a.addEventListener("click", (ev) => {
                  ev.preventDefault();
                  try { (window as any).__map_onSelect && (window as any).__map_onSelect(id); } catch {}
                });
              }
            }, 0);
          });

          updateMapboxData(map, points);
        });
      })();
    } else {
      (async () => {
        const Lmod: any = await import("leaflet");
        const L = Lmod.default ?? Lmod;

        const map = L.map(el, { zoomControl: true }).setView([20, -155], 6);
        L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "&copy; OpenStreetMap contributors",
          maxZoom: 19,
          detectRetina: true,
          updateWhenZooming: false,
          updateWhenIdle: true,
          crossOrigin: true,
        }).addTo(map);

        const layer = L.layerGroup().addTo(map);
        const index = new Supercluster({ radius: 60, maxZoom: 18, minPoints: 2 });

        // index of all points by rounded coord for richer popups on duplicate positions
        let dupIndex: Record<string, Point[]> = {};

        const makeBadge = (text: string, size = 28) => {
          const r = Math.round(size / 2);
          const html =
            '<div style="background:#2563eb;color:#fff;border:1px solid #fff;' +
            `width:${size}px;height:${size}px;border-radius:${r}px;display:flex;align-items:center;justify-content:center;` +
            'font-size:12px;font-weight:600;box-shadow:0 1px 2px rgba(0,0,0,0.25);">' +
            text +
            "</div>";
          return L.divIcon({ className: "cluster-pin", html, iconSize: [size, size], iconAnchor: [r, r] });
        };

        const render = () => {
          layer.clearLayers();

          const b = map.getBounds();
          const bbox: [number, number, number, number] = [
            b.getWest(),
            b.getSouth(),
            b.getEast(),
            b.getNorth(),
          ];
          const clusters = index.getClusters(bbox, map.getZoom());

          // count how many unclustered share the same rounded coordinate
          const counts: Record<string, number> = {};
          for (const c of clusters) {
            if (!c.properties.cluster) {
              const [lon, lat] = c.geometry.coordinates as [number, number];
              const key = `${lat.toFixed(5)}|${lon.toFixed(5)}`;
              counts[key] = (counts[key] || 0) + 1;
            }
          }

          clusters.forEach((c: any) => {
            const [lon, lat] = c.geometry.coordinates as [number, number];

            if (c.properties.cluster) {
              const icon = makeBadge(String(c.properties.point_count), 28);
              const m = L.marker([lat, lon], { icon, zIndexOffset: 100 }).addTo(layer);
              m.on("click", () => {
                const nextZoom = Math.min(index.getClusterExpansionZoom(c.id), map.getMaxZoom());
                map.setView([lat, lon], nextZoom, { animate: true });
              });
            } else {
              const key = `${lat.toFixed(5)}|${lon.toFixed(5)}`;
              const countHere = counts[key] || 1;
              const icon = makeBadge(String(countHere), countHere > 1 ? 28 : 24);
              const m = L.marker([lat, lon], { icon, zIndexOffset: 90 }).addTo(layer);

              // Build popup content: list all points at this exact coordinate if multiple
              const pts = dupIndex[key] || [];
              let html = `<div style="font-size:12px;line-height:1.25">`;
              if (countHere > 1 && pts.length > 0) {
                html += `<div style="font-weight:600;margin-bottom:4px">${countHere} sightings here</div>`;
                html += `<div style="max-height:180px;overflow:auto">`;
                for (const p of pts) {
                  const sid = p.id ?? "";
                  const linkId = `lf-sel-${sid}-${Math.floor(Math.random() * 1e6)}`;
                  const date = p.date ? `${p.date}` : "—";
                  const who = p.photographer ? `${p.photographer}` : "—";
                  const tot = typeof p.total === "number" ? p.total : "—";
                  html += `<div style="display:flex;gap:6px;align-items:center;margin:2px 0">
                    <a id="${linkId}" href="#" style="color:#2563eb;text-decoration:underline">#${sid}</a>
                    <span style="color:#6b7280">| ${date} · ${who} · ${tot} manta(s)</span>
                  </div>`;
                }
                html += `</div>`;
              } else {
                const sid = c.properties?.id;
                const linkId = `lf-sel-${sid}-${Math.floor(Math.random() * 1e6)}`;
                html += `<div><b>Sighting</b> <a id="${linkId}" href="#" style="color:#2563eb;text-decoration:underline">${sid}</a></div>`;
              }
              html += `</div>`;

              m.bindPopup(html);
              m.on("popupopen", () => {
                if (countHere > 1 && pts.length > 0) {
                  for (const p of pts) {
                    const sid = p.id ?? "";
                    const linkId = Array.from(
                      (m.getPopup().getElement() as HTMLElement).querySelectorAll(`[id^="lf-sel-${sid}-"]`)
                    )[0] as HTMLElement | undefined;
                    if (linkId) {
                      linkId.onclick = (ev: any) => {
                        ev.preventDefault();
                        try { (window as any).__map_onSelect && (window as any).__map_onSelect(Number(sid)); } catch {}
                      };
                    }
                  }
                } else {
                  const sid = c.properties?.id;
                  const link = Array.from(
                    (m.getPopup().getElement() as HTMLElement).querySelectorAll(`[id^="lf-sel-${sid}-"]`)
                  )[0] as HTMLElement | undefined;
                  if (link) {
                    link.onclick = (ev: any) => {
                      ev.preventDefault();
                      try { (window as any).__map_onSelect && (window as any).__map_onSelect(Number(sid)); } catch {}
                    };
                  }
                }
              });
            }
          });
        };

        function setLeafletData(pts: Point[]) {
          const feats = (pts || []).map((p) => ({
            type: "Feature" as const,
            properties: { id: p.id ?? null },
            geometry: { type: "Point" as const, coordinates: [p.lon, p.lat] },
          }));
          index.load(feats as any);

          // rebuild duplicate index for richer popups
          const tmp: Record<string, Point[]> = {};
          for (const p of pts || []) {
            const key = `${(p.lat ?? 0).toFixed(5)}|${(p.lon ?? 0).toFixed(5)}`;
            (tmp[key] ||= []).push(p);
          }
          dupIndex = tmp;

          if (pts && pts.length) {
            const L = Lmod.default ?? Lmod;
            const bounds = (L as any).latLngBounds(pts.map((p) => (L as any).latLng(p.lat, p.lon)));
            if (bounds.isValid()) {
              map.once("moveend", () => { render(); });
              map.fitBounds(bounds, { padding: [40, 40] });
            } else {
              render();
            }
          } else {
            render();
          }
        }

        mapHolder.current = { map, layer, engine: "leaflet", index, setLeafletData, render };
        setLeafletData(points);
        map.on("moveend", () => mapHolder.current?.render());
        map.on("zoomend", () => mapHolder.current?.render());
        setTimeout(() => { try { map.invalidateSize(); } catch {} }, 0);
        setTimeout(() => { try { map.invalidateSize(); } catch {} }, 150);
        setTimeout(() => { try { map.invalidateSize(); } catch {} }, 350);
      })();
    }
  }, [open, ready, engine]);

  useEffect(() => {
    if (!open || !mapHolder.current?.map) return;
    if (mapHolder.current.engine === "mapbox") {
      updateMapboxData(mapHolder.current.map, points);
    } else if (typeof mapHolder.current.setLeafletData === "function") {
      mapHolder.current.setLeafletData(points);
    }
  }, [open, points]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-6xl p-0 overflow-hidden">
        <DialogHeader className="px-4 pt-3 pb-2">
          <DialogTitle>Map</DialogTitle>
          {typeof totalFiltered === "number" && (
            <div className="text-xs text-muted-foreground">
              Showing {points?.length ?? 0} of {totalFiltered} filtered records with coordinates
            </div>
          )}
        </DialogHeader>
        {children && <div className="px-4 pb-3 border-b bg-muted/30">{children}</div>}
        <div className="w-full h-[540px]">
          {!points || points.length === 0 ? (
            <div className="flex h-full w-full items-center justify-center text-sm text-muted-foreground">
              No mappable points.
            </div>
          ) : (
            <div ref={containerRef} className="w-full h-full" />
          )}
        </div>
        {engine === "leaflet" && (
          <div className="px-4 pb-3 text-xs text-muted-foreground">
            Rendering with Leaflet (OpenStreetMap tiles). Add <code>VITE_MAPBOX_TOKEN</code> to enable Mapbox.
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
}

function updateMapboxData(map: any, pts: Point[]) {
  const src: any = map.getSource && map.getSource("sightings");
  if (!src) return;
  const fc = {
    type: "FeatureCollection",
    features: (pts || []).map((p) => ({
      type: "Feature",
      properties: { id: p.id ?? null },
      geometry: { type: "Point", coordinates: [p.lon, p.lat] },
    })),
  };
  try { src.setData(fc); } catch {}
}

async function webglSupported(): Promise<boolean> {
  try {
    const { default: mapboxgl } = await import("mapbox-gl");
    return typeof mapboxgl.supported === "function" ? mapboxgl.supported() : false;
  } catch {
    return false;
  }
}
