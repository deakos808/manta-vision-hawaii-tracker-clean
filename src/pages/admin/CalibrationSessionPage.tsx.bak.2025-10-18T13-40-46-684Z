import { useEffect, useState } from "react";
import { Link, useParams } from "react-router-dom";
import Layout from "@/components/layout/Layout";
import { supabase } from "@/lib/supabaseClient";
import { fmtMeters } from "../../utils/format";
import CalibrationPhotoCard, { PhotoResult } from "../../components/calibration/CalibrationPhotoCard";
import { Pencil, Trash2, X, Plus } from "lucide-react";

type Session = {
  id: string;
  photographer_name: string | null;
  camera_model: string | null;
  lens_type: string | null;
  laser_setup: string | null;
  default_scale_m: number;
  created_at: string;
};

type PhotoRow = {
  id: string;
  storage_path: string;
  width_px: number | null;
  height_px: number | null;
  actual_length_m: number | null;
  signed_url?: string | null;
  m?: {
    scale_px: number;
    object_px: number;
    scale_m: number;
    est_length_m: number;
    error_pct: number;
    scale_p0: any;
    scale_p1: any;
    object_p0: any;
    object_p1: any;
  } | null;
};

type QueueItem = {
  id: string;
  file: File;
  url: string;
  width: number;
  height: number;
  result?: PhotoResult;
  isDuplicateName?: boolean;
};

function baseName(p: string){ const i=p.lastIndexOf('/'); return i>=0 ? p.slice(i+1) : p; }
function safeName(n: string){ return n.replace(/[^a-zA-Z0-9._-]/g,'_'); }
function useImageDims(file: File): Promise<{url:string;width:number;height:number}> {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => resolve({ url, width: img.width, height: img.height });
    img.onerror = reject;
    img.src = url;
  });
}

export default function CalibrationSessionPage(){
  const { id } = useParams();
  const [sess, setSess] = useState<Session | null>(null);
  const [photos, setPhotos] = useState<PhotoRow[]>([]);
  const [loading, setLoading] = useState(true);
  const [editMeta, setEditMeta] = useState(false);
  const [meta, setMeta] = useState<{photographer_name:string;camera_model:string;lens_type:string;laser_setup:string}>({photographer_name:"",camera_model:"",lens_type:"",laser_setup:""});

  // modal: edit one existing photo
  const [modalOpen, setModalOpen] = useState(false);
  const [modalTarget, setModalTarget] = useState<PhotoRow | null>(null);
  const [modalResult, setModalResult] = useState<PhotoResult | null>(null);

  // modal: add multiple new photos
  const [addOpen, setAddOpen] = useState(false);
  const [queue, setQueue] = useState<QueueItem[]>([]);

  const scaleM = sess?.default_scale_m ?? 0.60;

  // load
  useEffect(()=>{ (async()=>{
    if (!id) return;
    setLoading(true);
    try{
      const { data: srow, error: se } = await supabase.from("calibration_sessions").select("*").eq("id", id).single();
      if (se) throw se;

      const { data: prows, error: pe } = await supabase
        .from("calibration_photos")
        .select("id, storage_path, width_px, height_px, actual_length_m")
        .eq("session_id", id)
        .order("created_at", { ascending: true });
      if (pe) throw pe;

      const photoIds = (prows||[]).map(p=>p.id);
      const measMap = new Map<string, any>();
      if (photoIds.length){
        const { data: mrows, error: me } = await supabase
          .from("calibration_measurements")
          .select("*")
          .in("photo_id", photoIds);
        if (me) throw me;
        for (const m of (mrows||[])) measMap.set(m.photo_id, m);
      }

      const withUrls: PhotoRow[] = [];
      for (const p of (prows||[])){
        const { data: u } = await supabase.storage.from("calibration-images").createSignedUrl(p.storage_path, 3600);
        withUrls.push({ ...p, signed_url: u?.signedUrl ?? null, m: measMap.get(p.id) || null });
      }

      setSess(srow as Session);
      setMeta({
        photographer_name: srow.photographer_name ?? "",
        camera_model: srow.camera_model ?? "",
        lens_type: srow.lens_type ?? "",
        laser_setup: srow.laser_setup ?? "",
      });
      setPhotos(withUrls);
    } finally { setLoading(false); }
  })(); }, [id]);

  const measured = photos.filter(p=>p.m);
  const meanErr = measured.length ? measured.reduce((a,p)=>a+(p.m!.error_pct||0),0)/measured.length : null;
  const meanErrTxt = meanErr!=null && isFinite(meanErr) ? meanErr.toFixed(2)+"%" : "-";

  async function saveMeta(){
    if(!sess) return;
    const patch = {
      photographer_name: meta.photographer_name || null,
      camera_model: meta.camera_model || null,
      lens_type: meta.lens_type || null,
      laser_setup: meta.laser_setup || null,
    };
    const { error } = await supabase.from("calibration_sessions").update(patch).eq("id", sess.id);
    if (error) throw error;
    setSess(prev => prev ? ({...prev, ...patch}) as any : prev);
    setEditMeta(false);
  }

  function openEditModal(row: PhotoRow){
    setModalTarget(row);
    setModalResult(null);
    setModalOpen(true);
  }
  function closeEditModal(){ setModalOpen(false); setModalTarget(null); setModalResult(null); }

  async function saveEditModal(){
    if(!modalTarget || !modalResult || !sess) return;
    const r = modalResult;
    if(!(r.scalePx>0 && r.objectPx>0 && (r.actualLengthM ?? 0) > 0)){
      alert("Draw both lines and enter actual length (m)."); return;
    }
    const actual = Number(r.actualLengthM);
    const est = r.estLengthM != null ? Number(r.estLengthM) : (r.scalePx>0 ? (r.objectPx/r.scalePx)*scaleM : null);
    if (est == null){ alert("Could not compute estimate."); return; }
    const errPct = Math.abs(est - actual)/actual*100;

    const { error: pErr } = await supabase.from("calibration_photos")
      .update({ actual_length_m: actual })
      .eq("id", modalTarget.id);
    if (pErr) throw pErr;

    await supabase.from("calibration_measurements").delete().eq("photo_id", modalTarget.id);
    const { error: mErr } = await supabase.from("calibration_measurements").insert([{
      photo_id: modalTarget.id,
      scale_px: r.scalePx,
      object_px: r.objectPx,
      scale_p0: r.scale.p0, scale_p1: r.scale.p1,
      object_p0: r.object.p0, object_p1: r.object.p1,
      scale_m: scaleM,
      est_length_m: est,
      error_pct: errPct
    }]);
    if (mErr) throw mErr;

    const { data: u } = await supabase.storage.from("calibration-images").createSignedUrl(modalTarget.storage_path, 3600);
    setPhotos(prev=>prev.map(p=> p.id===modalTarget.id ? ({
      ...p,
      actual_length_m: actual,
      signed_url: u?.signedUrl ?? p.signed_url,
      m: {
        scale_px: r.scalePx, object_px: r.objectPx, scale_m: scaleM, est_length_m: est, error_pct: errPct,
        scale_p0: r.scale.p0, scale_p1: r.scale.p1, object_p0: r.object.p0, object_p1: r.object.p1
      }
    }) : p));
    closeEditModal();
  }

  async function deletePhoto(row: PhotoRow){
    if(!confirm("Delete this photo and its measurement?")) return;
    await supabase.storage.from("calibration-images").remove([row.storage_path]);
    await supabase.from("calibration_measurements").delete().eq("photo_id", row.id);
    await supabase.from("calibration_photos").delete().eq("id", row.id);
    setPhotos(prev=>prev.filter(p=>p.id!==row.id));
  }

  // ----- Add photos modal -----
  const existingNames = new Set(photos.map(p => baseName(p.storage_path)));

  async function onAddFiles(files: FileList | null){
    if(!files || !files.length) return;
    const items: QueueItem[] = [];
    for(const f of Array.from(files)){
      if(!f.type.startsWith("image/")) continue;
      const meta = await useImageDims(f);
      const dispW = Math.min(900, meta.width);
      items.push({
        id: crypto.randomUUID(),
        file: f,
        url: meta.url,
        width: dispW,
        height: Math.round(meta.height*(dispW/meta.width)),
        isDuplicateName: existingNames.has(safeName(f.name))
      });
    }
    setQueue(prev => [...prev, ...items]);
  }

  async function saveAddModal(){
    if(!sess) return;
    const good = queue.filter(q => q.result && q.result.scalePx>0 && q.result.objectPx>0 && (q.result.actualLengthM ?? 0) > 0) as Required<QueueItem>[];
    if(!good.length){ alert("Add at least one fully measured photo."); return; }

    for(const q of good){
      const filename = safeName(q.file.name);
      const path = `calibration/${sess.id}/${filename}`;
      const up = await supabase.storage.from("calibration-images").upload(path, q.file, { upsert:true });
      if (up.error) throw up.error;

      const { data: prow, error: pErr } = await supabase
        .from("calibration_photos")
        .insert([{
          session_id: sess.id,
          storage_path: path,
          width_px: q.width,
          height_px: q.height,
          actual_length_m: Number(q.result.actualLengthM),
        }]).select("id").single();
      if (pErr) throw pErr;

      const est = q.result.estLengthM != null ? Number(q.result.estLengthM) : (q.result.objectPx/q.result.scalePx)*scaleM;
      const errPct = Math.abs(est - Number(q.result.actualLengthM))/Number(q.result.actualLengthM)*100;

      const { error: mErr } = await supabase.from("calibration_measurements").insert([{
        photo_id: prow!.id,
        scale_px: q.result.scalePx, object_px: q.result.objectPx,
        scale_p0: q.result.scale.p0, scale_p1: q.result.scale.p1,
        object_p0: q.result.object.p0, object_p1: q.result.object.p1,
        scale_m: scaleM, est_length_m: est, error_pct: errPct
      }]);
      if (mErr) throw mErr;

      const { data: u } = await supabase.storage.from("calibration-images").createSignedUrl(path, 3600);
      setPhotos(prev=>[...prev, {
        id: prow!.id, storage_path: path, width_px: q.width, height_px: q.height, actual_length_m: Number(q.result.actualLengthM),
        signed_url: u?.signedUrl ?? null,
        m: { scale_px: q.result.scalePx, object_px: q.result.objectPx, scale_m: scaleM, est_length_m: est, error_pct: errPct,
             scale_p0: q.result.scale.p0, scale_p1: q.result.scale.p1, object_p0: q.result.object.p0, object_p1: q.result.object.p1 }
      }]);
    }

    setQueue([]);
    setAddOpen(false);
  }

  if (!id) return <Layout><div className="p-6">Missing session id.</div></Layout>;
  if (loading) return <Layout><div className="p-6">Loading…</div></Layout>;
  if (!sess) return <Layout><div className="p-6">Session not found.</div></Layout>;

  return (
    <Layout>
      <div className="p-6 space-y-4">
        {/* Breadcrumb */}
        <nav className="text-sm">
          <Link to="/admin" className="text-sky-700 hover:underline">Admin</Link>
          <span className="mx-1">/</span>
          <Link to="/admin/calibration" className="text-sky-700 hover:underline">Calibration</Link>
          <span className="mx-1">/</span>
          <span className="text-slate-500">{id}</span>
        </nav>

        {/* Header card */}
        <div className="rounded-lg border bg-white p-4">
          {!editMeta ? (
            <>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                <div><span className="text-slate-500">Photographer:</span> {sess.photographer_name || "-"}</div>
                <div><span className="text-slate-500">Camera:</span> {sess.camera_model || "-"}</div>
                <div><span className="text-slate-500">Lens:</span> {sess.lens_type || "-"}</div>
                <div><span className="text-slate-500">Laser setup:</span> {sess.laser_setup || "-"}</div>
                <div><span className="text-slate-500">Default scale:</span> {fmtMeters(sess.default_scale_m)}</div>
                <div><span className="text-slate-500">Created:</span> {new Date(sess.created_at).toLocaleString()}</div>
              </div>
              <div className="mt-2 text-sm text-slate-600">
                <span className="mr-4">Photos: {photos.length}</span>
                <span className="mr-4">Measured: {measured.length}</span>
                <span>Mean error: {meanErrTxt}</span>
              </div>
              <div className="mt-3 flex gap-2">
                <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={()=>setEditMeta(true)}>Edit</button>
                <button className="inline-flex items-center gap-1 rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={()=>{ setAddOpen(true); setQueue([]); }}>
                  <Plus className="w-4 h-4" /> Add photos
                </button>
              </div>
            </>
          ) : (
            <>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                <label className="flex flex-col gap-1">
                  <span className="text-slate-500">Photographer</span>
                  <input className="border rounded-md px-3 py-2" value={meta.photographer_name} onChange={e=>setMeta({...meta, photographer_name:e.target.value})}/>
                </label>
                <label className="flex flex-col gap-1">
                  <span className="text-slate-500">Camera</span>
                  <input className="border rounded-md px-3 py-2" value={meta.camera_model} onChange={e=>setMeta({...meta, camera_model:e.target.value})}/>
                </label>
                <label className="flex flex-col gap-1">
                  <span className="text-slate-500">Lens</span>
                  <input className="border rounded-md px-3 py-2" value={meta.lens_type} onChange={e=>setMeta({...meta, lens_type:e.target.value})}/>
                </label>
                <label className="flex flex-col gap-1">
                  <span className="text-slate-500">Laser setup</span>
                  <input className="border rounded-md px-3 py-2" value={meta.laser_setup} onChange={e=>setMeta({...meta, laser_setup:e.target.value})}/>
                </label>
              </div>
              <div className="mt-3 flex gap-2">
                <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={saveMeta}>Save</button>
                <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={()=>{ setEditMeta(false); setMeta({
                  photographer_name: sess.photographer_name ?? "", camera_model: sess.camera_model ?? "",
                  lens_type: sess.lens_type ?? "", laser_setup: sess.laser_setup ?? ""
                });}}>Cancel</button>
              </div>
            </>
          )}
        </div>

        {/* Photos table */}
        <div className="overflow-x-auto border rounded-lg bg-white">
          <table className="min-w-full text-sm">
            <thead className="bg-slate-50 text-slate-600">
              <tr>
                <th className="text-left px-3 py-2">Photo</th>
                <th className="text-left px-3 py-2">File</th>
                <th className="text-right px-3 py-2">Scale (px)</th>
                <th className="text-right px-3 py-2">Object (px)</th>
                <th className="text-right px-3 py-2">Scale (m)</th>
                <th className="text-right px-3 py-2">Estimated (m)</th>
                <th className="text-right px-3 py-2">Actual (m)</th>
                <th className="text-right px-3 py-2">% error</th>
                <th className="text-right px-3 py-2">Actions</th>
              </tr>
            </thead>
            <tbody>
              {photos.map(p => (
                <tr key={p.id} className="border-t">
                  <td className="px-3 py-2">
                    {p.signed_url ? <img src={p.signed_url} className="w-24 h-16 object-cover rounded border" /> : "-"}
                  </td>
                  <td className="px-3 py-2">{baseName(p.storage_path)}</td>
                  <td className="px-3 py-2 text-right">{p.m ? Math.round(p.m.scale_px) : "-"}</td>
                  <td className="px-3 py-2 text-right">{p.m ? Math.round(p.m.object_px) : "-"}</td>
                  <td className="px-3 py-2 text-right">{p.m ? fmtMeters(p.m.scale_m) : "-"}</td>
                  <td className="px-3 py-2 text-right">{p.m ? fmtMeters(p.m.est_length_m) : "-"}</td>
                  <td className="px-3 py-2 text-right">{p.actual_length_m!=null ? fmtMeters(p.actual_length_m) : "-"}</td>
                  <td className="px-3 py-2 text-right">{p.m ? p.m.error_pct.toFixed(2)+"%" : "-"}</td>
                  <td className="px-3 py-2 text-right">
                    <button className="inline-flex items-center gap-1 px-2 py-1 rounded-md border hover:bg-slate-50 mr-2" onClick={()=>openEditModal(p)} title="Edit">
                      <Pencil className="w-4 h-4" /><span className="sr-only">Edit</span>
                    </button>
                    <button className="inline-flex items-center gap-1 px-2 py-1 rounded-md border hover:bg-rose-50 text-rose-700" onClick={()=>deletePhoto(p)} title="Delete">
                      <Trash2 className="w-4 h-4" /><span className="sr-only">Delete</span>
                    </button>
                  </td>
                </tr>
              ))}
              {photos.length===0 && (
                <tr>
                  <td className="px-3 py-6 text-center text-slate-500" colSpan={9}>No photos.</td>
                </tr>
              )}
            </tbody>
          </table>
        </div>

        {/* Edit modal */}
        {modalOpen && modalTarget && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
            <div className="bg-white rounded-lg border shadow-lg max-w-5xl w-[95vw] max-h-[90vh] overflow-auto p-4">
              <div className="flex items-center justify-between mb-2">
                <div className="font-medium">Edit measurement — {baseName(modalTarget.storage_path)}</div>
                <button className="p-1 rounded hover:bg-slate-100" onClick={closeEditModal} aria-label="Close"><X className="w-4 h-4" /></button>
              </div>
              <CalibrationPhotoCard
                photo={{
                  id: modalTarget.id,
                  url: modalTarget.signed_url || "",
                  width: Math.min(900, modalTarget.width_px || 900),
                  height: Math.round((modalTarget.height_px || 900) * (Math.min(900, modalTarget.width_px || 900) / (modalTarget.width_px || 900))),
                  label: "#"
                }}
                defaultScaleM={scaleM}
                onChange={(r)=>setModalResult(r)}
              />
              <div className="mt-3 flex justify-end gap-2">
                <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={closeEditModal}>Cancel</button>
                <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={saveEditModal}>Save</button>
              </div>
            </div>
          </div>
        )}

        {/* Add photos modal */}
        {addOpen && (
          <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
            <div className="bg-white rounded-lg border shadow-lg max-w-6xl w-[96vw] max-h-[92vh] overflow-auto p-4">
              <div className="flex items-center justify-between mb-2">
                <div className="font-medium">Add photos</div>
                <button className="p-1 rounded hover:bg-slate-100" onClick={()=>{ setAddOpen(false); setQueue([]); }} aria-label="Close"><X className="w-4 h-4" /></button>
              </div>

              <div
                className="rounded-lg border border-dashed p-6 bg-white text-center"
                onDragOver={(e)=>e.preventDefault()}
                onDrop={(e)=>{ e.preventDefault(); onAddFiles(e.dataTransfer.files); }}
              >
                <div className="text-sm text-slate-600 mb-3">Drag &amp; drop photos here, or</div>
                <label className="inline-flex items-center gap-2 px-3 py-2 border rounded-md cursor-pointer hover:bg-slate-50">
                  <input type="file" accept="image/*" multiple className="hidden" onChange={(e)=>onAddFiles(e.target.files)} />
                  <span>Select images</span>
                </label>
              </div>

              {queue.length>0 ? (
                <div className="mt-4 space-y-6">
                  {queue.map((q,idx)=>(
                    <div key={q.id} className="rounded-lg border bg-white p-4">
                      <div className="flex items-center justify-between mb-2">
                        <div className="text-sm font-medium">New photo #{idx+1} — <span className={q.isDuplicateName ? "text-rose-700" : ""}>{safeName(q.file.name)}</span>{q.isDuplicateName ? " (duplicate filename)" : ""}</div>
                        <button className="rounded-md border px-2 py-1 text-sm hover:bg-slate-50" onClick={()=>setQueue(prev=>prev.filter(x=>x.id!==q.id))}>Remove</button>
                      </div>
                      <CalibrationPhotoCard
                        photo={{ id:q.id, url:q.url, width:q.width, height:q.height, label:"#"}}
                        defaultScaleM={scaleM}
                        onChange={(r)=>setQueue(prev=>prev.map(x=>x.id===q.id ? {...x, result:r} : x))}
                      />
                    </div>
                  ))}
                  <div className="flex justify-end gap-2">
                    <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={()=>{ setAddOpen(false); setQueue([]); }}>Cancel</button>
                    <button className="rounded-md border px-3 py-2 text-sm hover:bg-slate-50" onClick={saveAddModal}>Save</button>
                  </div>
                </div>
              ) : (
                <div className="text-sm text-slate-500 mt-4">No files in queue yet.</div>
              )}
            </div>
          </div>
        )}
      </div>
    </Layout>
  );
}
