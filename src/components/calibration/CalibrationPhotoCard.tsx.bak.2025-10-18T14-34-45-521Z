import React, { useEffect, useRef, useState } from "react";
import CalibrationLineCanvas, { CanvasState } from "./CalibrationLineCanvas";
import { fmtMeters } from "../../utils/format";

export type PhotoModel = {
  id: string;
  url: string;
  file?: File;
  width: number;
  height: number;
  label?: string; // e.g., "#1"
};

export type PhotoResult = {
  scalePx: number;
  objectPx: number;
  estLengthM: number | null;
  actualLengthM: number | null;
  errorPct: number | null;
  diffM: number | null;
  // raw points for persistence
  scale: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
  object: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
};

export default function CalibrationPhotoCard({
  photo,
  defaultScaleM,
  onChange,
  initial,
}: {
  photo: PhotoModel;
  defaultScaleM: number;
  onChange?: (r: PhotoResult) => void;
  initial?: {
    scale?: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
    object?: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
    actual?: number | null;
  };
}) {
  const [canvas, setCanvas] = useState<CanvasState>({ scale:{p0:null,p1:null}, object:{p0:null,p1:null}, scalePx:0, objectPx:0 });
  const [actualM, setActualM] = useState<string>("");

  // responsive sizing to prevent overlap
  const colRef = useRef<HTMLDivElement>(null);
  const [dispW, setDispW] = useState<number>(photo.width);
  const [dispH, setDispH] = useState<number>(photo.height);

  // loupe state
  const [showZoom, setShowZoom] = useState<boolean>(true);
  const [cursor, setCursor] = useState<{x:number;y:number}|null>(null);
  const [zoom, setZoom] = useState<number>(3.0);  // magnification
  const [loupe, setLoupe] = useState<number>(160);  // diameter (px)

  useEffect(()=>{
    function recalc(){
      const avail = colRef.current?.clientWidth ?? photo.width;
      const nextW = Math.min(avail, photo.width);
      const nextH = Math.round(photo.height * (nextW / photo.width));
      setDispW(nextW);
      setDispH(nextH);
    }
    recalc();
    window.addEventListener('resize', recalc);
    return ()=>window.removeEventListener('resize', recalc);
  }, [photo.width, photo.height]);

  function compute(canvasState: CanvasState, actualStr: string): PhotoResult {
    const scalePx = canvasState.scalePx;
    const objectPx = canvasState.objectPx;
    const scaleM = defaultScaleM; // v1 uses session default
    let est: number | null = null;
    if (scalePx > 0 && objectPx > 0 && scaleM > 0) est = (objectPx / scalePx) * scaleM;
    const actual = actualStr ? Number(actualStr) : null;
    let errorPct: number | null = null;
    let diffM: number | null = null;
    if (est != null && actual != null && actual > 0) {
      diffM = Math.abs(est - actual);
      errorPct = (Math.abs(est - actual) / actual) * 100;
    }
    return {
      scalePx, objectPx,
      estLengthM: est,
      actualLengthM: actual,
      errorPct,
      diffM,
      scale: canvasState.scale,
      object: canvasState.object,
    };
  }

  useEffect(()=>{ onChange?.(compute(canvas, actualM)); }, [canvas, actualM]);

  return (
    <div className="border rounded-lg overflow-hidden bg-white">
      <div className="flex items-center justify-between px-4 py-2 border-b bg-slate-50">
        <div className="font-medium">{photo.label || "Photo"}</div>
        <div className="text-xs text-slate-600">Default scale: {fmtMeters(defaultScaleM)}</div>
      </div>
      <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-4">
        <div ref={colRef} className="relative overflow-hidden">
          <div
            className="relative inline-block w-full"
            style={{ maxWidth: '100%' }}
            onMouseMove={(e)=>{
              const rect = (e.currentTarget.querySelector('img') as HTMLImageElement)?.getBoundingClientRect();
              if(!rect) return;
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              setCursor({ x: Math.max(0, Math.min(dispW, x)), y: Math.max(0, Math.min(dispH, y)) });
            }}
            onMouseLeave={()=>setCursor(null)}
          >
            <div className="relative" style={{ width: dispW, height: dispH }}>
              <img
                src={photo.url}
                width={dispW}
                height={dispH}
                className="block w-full h-auto max-w-full select-none rounded-md border"
                alt="calibration"
              />
              <div className="absolute inset-0">
                <CalibrationLineCanvas
                  width={dispW}
                  height={dispH}
                  onChange={(s)=>setCanvas(s)}
                />
              </div>
              {/* loupe magnifier */}
              {showZoom && cursor && (() => {
  // Desired lens origin if placed to the right/bottom of cursor
  const P = 16; // padding between cursor and lens
  let left = cursor.x + P;
  let top  = cursor.y + P;

  // If lens would overflow right/bottom, flip to left/top
  if (left + loupe > dispW) left = cursor.x - loupe - P;
  if (top  + loupe > dispH) top  = cursor.y - loupe - P;

  // Clamp to image
  left = Math.max(0, Math.min(dispW - loupe, left));
  top  = Math.max(0, Math.min(dispH - loupe, top));

  return (
    <div
      className="pointer-events-none absolute rounded-full border border-slate-400 shadow-sm z-30 bg-white/5"
      style={{
        width: loupe,
        height: loupe,
        left,
        top,
        backgroundImage: `
  linear-gradient(rgba(255,255,255,0.95), rgba(255,255,255,0.95)),
  linear-gradient(rgba(255,255,255,0.95), rgba(255,255,255,0.95)),
  radial-gradient(circle at center, rgba(255,255,255,1) 0 3px, rgba(0,0,0,0.35) 3px 4px, rgba(255,255,255,0) 4px),
  url(${photo.url})
`,
        backgroundRepeat: 'no-repeat',
        backgroundSize: `
  1px ${loupe}px,
  ${loupe}px 1px,
  6px 6px,
  ${dispW*zoom}px ${dispH*zoom}px
`,
        // Keep the *sample point* at the cursor even if the lens slides
        backgroundPosition: `
  ${loupe/2}px 0px,
  0px ${loupe/2}px,
  ${loupe/2-3}px ${loupe/2-3}px,
  ${-cursor.x*zoom + loupe/2}px ${-cursor.y*zoom + loupe/2}px
`,
        boxShadow: "0 0 0 1px rgba(255,255,255,.7) inset"
      }}
    />
  );
})() }
            </div>
          </div>
        </div>

        <div className="flex flex-col gap-3">
          <label className="flex flex-col gap-1">
            <span className="text-sm font-medium">Actual Object Length (m)</span>
            <input
              type="number" step="0.01" min="0.01"
              value={actualM}
              onChange={(e)=>setActualM(e.target.value)}
              placeholder="e.g., 0.60"
              className="border rounded-md px-3 py-2 w-40"
            />
            {canvas.scalePx>0 && canvas.objectPx>0 && !actualM && (
              <span className="text-xs text-rose-600">Enter actual length to compute % error and enable save.</span>
            )}
            <span className="text-xs text-slate-500">Required for % error.</span>
          </label>

          <div className="grid grid-cols-2 gap-2 text-sm">
            <div className="text-slate-500">Scale length (px)</div><div>{Math.round(canvas.scalePx)}</div>
            <div className="text-slate-500">Object length (px)</div><div>{Math.round(canvas.objectPx)}</div>
            <div className="text-slate-500">Estimated length</div>
            <div>{(compute(canvas, actualM).estLengthM != null) ? fmtMeters(compute(canvas, actualM).estLengthM!) : "-"}</div>
            <div className="text-slate-500">Î” length</div>
            <div>{(compute(canvas, actualM).diffM != null) ? fmtMeters(compute(canvas, actualM).diffM!) : "-"}</div>
            <div className="text-slate-500">% error</div>
            <div>{(compute(canvas, actualM).errorPct != null) ? compute(canvas, actualM).errorPct!.toFixed(2) + "%" : "-"}</div>
          </div>
        </div>
      </div>
    </div>
  );
}
