import React, { useEffect, useRef, useState } from "react";
import CalibrationLineCanvas, { CanvasState } from "./CalibrationLineCanvas";
import { fmtMeters } from "../../utils/format";

export type PhotoModel = {
  id: string;
  url: string;
  file?: File;
  width: number;
  height: number;
  label?: string; // e.g., "#1"
};

export type PhotoResult = {
  scalePx: number;
  objectPx: number;
  estLengthM: number | null;
  actualLengthM: number | null;
  errorPct: number | null;
  diffM: number | null;
  // raw points for persistence
  scale: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
  object: { p0: {x:number,y:number} | null; p1: {x:number,y:number} | null };
};

export default function CalibrationPhotoCard({
  photo,
  defaultScaleM,
  onChange,
}: {
  photo: PhotoModel;
  defaultScaleM: number;
  onChange?: (r: PhotoResult) => void;
}) {
  const [canvas, setCanvas] = useState<CanvasState>({ scale:{p0:null,p1:null}, object:{p0:null,p1:null}, scalePx:0, objectPx:0 });
  const [actualM, setActualM] = useState<string>("");

  // responsive sizing to prevent overlap
  const colRef = useRef<HTMLDivElement>(null);
  const [dispW, setDispW] = useState<number>(photo.width);
  const [dispH, setDispH] = useState<number>(photo.height);

  useEffect(()=>{
    function recalc(){
      const avail = colRef.current?.clientWidth ?? photo.width;
      const nextW = Math.min(avail, photo.width);
      const nextH = Math.round(photo.height * (nextW / photo.width));
      setDispW(nextW);
      setDispH(nextH);
    }
    recalc();
    window.addEventListener('resize', recalc);
    return ()=>window.removeEventListener('resize', recalc);
  }, [photo.width, photo.height]);

  function compute(canvasState: CanvasState, actualStr: string): PhotoResult {
    const scalePx = canvasState.scalePx;
    const objectPx = canvasState.objectPx;
    const scaleM = defaultScaleM; // v1 uses session default
    let est: number | null = null;
    if (scalePx > 0 && objectPx > 0 && scaleM > 0) est = (objectPx / scalePx) * scaleM;
    const actual = actualStr ? Number(actualStr) : null;
    let errorPct: number | null = null;
    let diffM: number | null = null;
    if (est != null && actual != null && actual > 0) {
      diffM = Math.abs(est - actual);
      errorPct = (Math.abs(est - actual) / actual) * 100;
    }
    return {
      scalePx, objectPx,
      estLengthM: est,
      actualLengthM: actual,
      errorPct,
      diffM,
      scale: canvasState.scale,
      object: canvasState.object,
    };
  }

  useEffect(()=>{ onChange?.(compute(canvas, actualM)); }, [canvas, actualM]);

  return (
    <div className="border rounded-lg overflow-hidden bg-white">
      <div className="flex items-center justify-between px-4 py-2 border-b bg-slate-50">
        <div className="font-medium">{photo.label || "Photo"}</div>
        <div className="text-xs text-slate-600">Default scale: {fmtMeters(defaultScaleM)}</div>
      </div>
      <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-4">
        <div ref={colRef} className="relative overflow-hidden">
          <div className="relative inline-block w-full" style={{ maxWidth: '100%' }}>
            <div className="relative" style={{ width: dispW, height: dispH }}>
              <img
                src={photo.url}
                width={dispW}
                height={dispH}
                className="block w-full h-auto max-w-full select-none rounded-md border"
                alt="calibration"
              />
              <div className="absolute inset-0">
                <CalibrationLineCanvas
                  width={dispW}
                  height={dispH}
                  onChange={(s)=>setCanvas(s)}
                />
              </div>
            </div>
          </div>
        </div>

        <div className="flex flex-col gap-3">
          <label className="flex flex-col gap-1">
            <span className="text-sm font-medium">Actual Object Length (m)</span>
            <input
              type="number" step="0.01" min="0.01"
              value={actualM}
              onChange={(e)=>setActualM(e.target.value)}
              placeholder="e.g., 0.60"
              className="border rounded-md px-3 py-2 w-40"
            />
            {canvas.scalePx>0 && canvas.objectPx>0 && !actualM && (
              <span className="text-xs text-rose-600">Enter actual length to compute % error and enable save.</span>
            )}
            <span className="text-xs text-slate-500">Required for % error.</span>
          </label>

          <div className="grid grid-cols-2 gap-2 text-sm">
            <div className="text-slate-500">Scale length (px)</div><div>{Math.round(canvas.scalePx)}</div>
            <div className="text-slate-500">Object length (px)</div><div>{Math.round(canvas.objectPx)}</div>
            <div className="text-slate-500">Estimated length</div>
            <div>{(compute(canvas, actualM).estLengthM != null) ? fmtMeters(compute(canvas, actualM).estLengthM!) : "-"}</div>
            <div className="text-slate-500">Î” length</div>
            <div>{(compute(canvas, actualM).diffM != null) ? fmtMeters(compute(canvas, actualM).diffM!) : "-"}</div>
            <div className="text-slate-500">% error</div>
            <div>{(compute(canvas, actualM).errorPct != null) ? compute(canvas, actualM).errorPct!.toFixed(2) + "%" : "-"}</div>
          </div>
        </div>
      </div>
    </div>
  );
}
